## 前言
Java虚拟机非常复杂，想要真正理解它的工作机制和设计原理，最好的方法就是自己动手写一个JVM。而非常幸运的是，我有机会参与到老师和师兄的JVM项目中去暗中观察和学习，
我把学习的总结和心得都写在了这里。希望这些文章能帮到一些曾经跟我一样对JVM一无所知却充满好奇的同学。

最后我们制作的JVM能够支持Java6的全部语句，虽然没有做关于垃圾回收的算法研究和优化，但已经足够我去学习了。本文是一个索引，将对JVM做一个
概述，每个部分的详细内容和设计细节被单独列出。

## 我眼中的JVM

虚拟机是通过软件的方式来模拟实现的机器（比如说计算机），它可以像物理机一样运行程序。设计虚拟机的初衷是让Java能够通过它来实现WORA(Write Once Run Anywhere 一次编译，到处运行），尽管这个目标现在已经被大多数人忽略了。因此，JVM可以在不修改Java代码的情况下，在所有的硬件环境上运行Java字节码。

在我看来虚拟机可以分成三个部分来理解：

### **①类加载器：**

**这部分虚拟机最主要的逻辑，也是虚拟机的核心。**

在Java8虚拟机规范中，只是大体概述了下虚拟机类加载的流程，并没有硬性的设计规范和要求，所以给每一个JVM制作者留下了很大的发挥想象力的空间。

我这里所说的类加载，作用不仅仅是define class这样将类加载的简单过程，还包括链接，验证(可以不做)，解析的过程。实际上对于一个java工程来说，这些组件在解释大量的class文件时没有明确的调用顺序，相互交织在一起，所以把它们放一起有一个整体的理解。

一个class文件进入虚拟机后，并不能直接运行，因为对于解释引擎来说这就是一堆二进制，你必须帮解释引擎去把class文件解析成可以直接按顺序执行的字节码内容。而在这个过程中，单个class文件大致经历了加载，链接和初始化三个过程。

* **加载**：按照系统的环境变量去找到JDK中所需要的系统类，按照虚拟机执行目录找到目标class文件，将它们的内容加载(怎么存储这些class文件完全取决于设计者，我们使用的是每个节点加上了互斥锁的链表)。拿到了这些class文件，便按照虚拟机的规范，把他们读取到设计好的JVM数据结构中，
比如**常量池，异常表，域描述，方法描述**。
* **链接**：链接指的是将Java类的二进制文件合并到jvm的运行状态之中的过程。
* **初始化**：初始化阶段是类加载过程的最后一步。到了初始化阶段，才真正执行类中定义的Java程序代码（或者说是字节码）。

[类加载](classloader.md)

### **②运行时数据结构：**
[JVM堆栈分析](stack_heap.md)

### **③解释引擎：**
[JVM解释引擎](exception.md)

