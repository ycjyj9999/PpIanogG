## 前言
Java虚拟机非常复杂，想要真正理解它的工作机制和设计原理，最好的方法就是自己动手写一个JVM。而非常幸运的是，我有机会参与到老师和师兄的JVM项目中去暗中观察和学习，
我把学习的总结和心得都写在了这里。希望这些文章能帮到一些曾经跟我一样对JVM一无所知却充满好奇的同学。

最后我们制作的JVM能够支持Java6的全部语句，虽然没有做关于垃圾回收的算法研究和优化，但已经足够我去学习了。本文是一个索引，将对JVM做一个
概述，每个部分的详细内容和设计细节被单独列出。

## 我眼中的JVM

虚拟机是通过软件的方式来模拟实现的机器（比如说计算机），它可以像物理机一样运行程序。设计虚拟机的初衷是让Java能够通过它来实现WORA(Write Once Run Anywhere 一次编译，到处运行），尽管这个目标现在已经被大多数人忽略了。因此，JVM可以在不修改Java代码的情况下，在所有的硬件环境上运行Java字节码。

在我看来虚拟机可以分成三个部分来理解：

### **①类加载器：**

**这部分虚拟机最主要的逻辑，也是虚拟机的核心。**

在Java8虚拟机规范中，只是大体概述了下虚拟机类加载的流程，并没有硬性的设计规范和要求，所以给每一个JVM制作者留下了很大的发挥想象力的空间。

我这里所说的类加载，作用不仅仅是define class这样将类加载的简单过程，还包括链接，验证(可以不做)，解析的过程。实际上对于一个java工程来说，这些组件在解释大量的class文件时没有明确的调用顺序，相互交织在一起，所以把它们放一起有一个整体的理解。

一个class文件进入虚拟机后，并不能直接运行，因为对于解释引擎来说这就是一堆二进制，你必须帮解释引擎去把class文件解析成可以直接按顺序执行的字节码内容。而在这个过程中，单个class文件大致经历了加载，链接和初始化三个过程。

[类加载](classloader.md)

### **②运行时数据结构：**

**虚拟机没有对运行时数据结构做硬性的规范，每个设计者心中都有自己的蓝图**

这里主要介绍的是传统的堆，栈，方法区，运行时常量池，本地方法调用栈的结构，他们的生命周期，作用，在运行时的变化，以及设计细节。

[JVM堆栈分析](stack_heap.md)

### **③解释引擎：**

**当一个加载的类走到解释引擎这个阶段，下面就会解释指令集并执行得出结果了**

在解释引擎阶段并没有太多可以分享的东西，绝大多数操作都是按照虚拟机的规范来进行，留给JVM开发者自己发挥的空间很小。这里给大家介绍俩个冷门的小知识点，本地方法调用和Java数组详解。

[Java数组](../JAVA/Shuzu.md)
[JVM本地方法调用](native.md)

