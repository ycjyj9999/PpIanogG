## JVM类加载器

本文将详细分析类加载过程中所用到的主要理论和技术。

以经典的虚拟机模型为背景，我们将顺序介绍**装载，连接和初始化**。

在开始之前，惯例，我们做一道题目热热身：

```java
package jt_test; 
class jtClassLoader {
    private static jtClassLoader sin = new jtClassLoader();
    public static int counter1;
    public static int counter2 = 0;

    public jtClassLoader() {
        counter1++;
        counter2++;
    }

    public static jtClassLoader getInstance() {
        return sin;
    }
}

public class Jtlyc {
    public static void main(String[] args) {
        jtClassLoader sin = jtClassLoader.getInstance();
        System.out.println(sin.counter1);
        System.out.println(sin.counter2);
    }
}  
```


**目前大家常用的jvm的执行结果是1和0，如果你答对了，知道其中细节和原理，并且能够完整的想象出得到这个结果的过程，那么继续往下读对你来说是在浪费时间。
**

**准确地来说，这道题目的正确结果是x+1和0(根据不同的虚拟机规范，x的取值不同)。**

### 需要准备的一些概念

①类，接口等java的语法概念，比如继承方法，实现接口等等，本文不会阐述java的语法规则

②在JVM的视角中，数组也是类。它是由虚拟机自己按照虚拟机规范，分配空间并定义数据结构而创作的类，在Java数组一文中阐述的很详细。

③在JVM中主要存储了三种类，分为**普通类，数组类，基本类**

* 普通类是虚拟机规范所定义的类,典型的,这些类一般存储在class文件中 
* 数组类包括一维或多维数组,数组元素的类型可以是基本类型,也可以是引用类型
* 基本类包括Java的9种基本类型,其中也 包括没有任何数据的void类型

④因为JVM有很多，每家公司设计的方式和规范也都不相同。所以我们在举例说明时，用“默认”描述的规范都是参考自openjdk和sun公司的JVM。

### 一、装载

类装载要完成的任务是把代表Java类数据的二进制流翻译成虚拟机内部的类数据结构。 虚拟机规范并没有规定
二进制流的来源:可以是从文件中读取的流、可以是从网络上下载的流、或者动态生成的流。**从虚拟机的角度
看,所有这些源都被看成相同的二进制流,并没有本质区别**。

在默认的虚拟机模型中，使用了递归下降分析法来读取并分析一个二进制
流表示的Java类;在分析的过程 中,构造相应的语法树中间表示。算法的伪代码如下:

```C
parseClass()
    parseMagic();
    parseVersion();
    parseConstantPool();
    parseAccessFlags();
    
```

**注意：**

* 类可能继承了其他类,并且类可能实现了接又,在装载的时候会递归的装载 该类的所有父类及父接又;一直到Object类为止。从Java的继承层次上看,每次装载
都会使得类的继承树上从当前节点到根节点的一条路径被完全装载完毕。

* 在Java中,所有的类同时又是java/lang/Class类的对象,因此,在类的装载 阶段,会装载java/lang/Class类,并在所有的类(包括java/lang/Class类自身)都设置好一个指向java/lang/Class类的域

* 数组类和基本类型并没有相对应的二进制流表示,因此,从类加载的角度看,这两种类是被直接在虚拟机里创建的,而不是装载的。并且,这两种也不需要进行准备和初始化。

--------------

### 二、连接
在完成装载后，JVM可以在自己的存储空间中(在经典的虚拟机设计中是**方法区**)找到它需要的任意类所对应的数据结构(clinit，init，域，方法，异常表等等)，但这些数据结构最后指向的还是二进制流，JVM并不能拿来直接进行运算，并且JVM也不知道要给这个类的对象分配多少空间，它的状态，它父类的状态等等信息。

**只有当在连接状态完成之后，一个对于JVM来说具备可识别可直接引用的类才算真正完成，那么下面我们将详细介绍下连接阶段虚拟机的工作内容和设计理念。**

一般来说连接在JVM中分为三个步骤：**验证，准备，解析**。

验证做的事情比较繁琐，工作量大但逻辑简单，主要是根据JVM规范中规定的对class文件内容进行校验，比如说class文件的魔数，偏移量的匹配，method和field的flag合法性等等，这里就一笔带过。
我们主要介绍下准备和解析过程。

#### 准备

准备阶段主要做了俩件事情：

###### ①赋值

准备阶段完成了对每一个类当中，所有的类静态域分配相应的空间，并用虚拟机规范的默认值进行赋值。比如static int型的默认值在JVM规范1.0中是-1，而在后来的版本中均为0。

**注意：**

* 这里是对类的静态域分配空间和赋值，并不是对象。这里的类就是只正常的普通类。
* 当我们每次进行new操作时，也就是在JVM中解释new指令时，会对(默认为存储在方法区中)已经装载的类的内存空间

###### ②虚方法表

在默认的虚拟机原型中，JVM会在准备阶段构建每一个类的虚方法表。虚方法表可以大大提升调用方法的效率和准确性。

使用递归的思想，为一个类构造虚方法表的算法非常简单，以构建类a的虚方法表为例我给大家写一下伪代码：

```C
create-vtable(aClass)
    vtable = null;
    if(aClass->super)
        create-vtable(aClass->super);
    copy-vtable(vtable, aClass->vtable);
    foreach(method m in aClass)
        add-or-replace(vtable, m);
```
简单来说，当一个需要完成准备状态的Class被交给虚方法表构建器(我起名为create-vtable)。会先遍历这个类的所有父类，直至根部。然后从根部开始层层回调，
每一次都把当前访问到的类的所有方法相关的数据结构（用javap命令可以看见详细内容，即methodRef),记录到这张表上。

**注意：**
在递归构造父类的虚方法表后(第4行),会把父类
的虚方法表拷贝到 当前类当中(第5行),遍历当前类
的所有方法,把它添加到虚方法表中(6-7行), 在添加
的过程中,不是简单的追加,而是可能会覆盖父类中的
方法。

#### 解析

解析阶段要完成的任务是对常量池中所有出现的符号引用进行查找,都替换成直接引用。 从编译观点看,这相
当于一个代码翻译的任务,即把符号引用翻译成指向虚拟机内部 恰当中间表示的实际引用。

以下的例子非常简单,但说明了在解析过程中需要完成的工作:

```java
class A{
  static int x = 99;
}
class B{
  static int y = A.x;
}
```
第6行的字段引用A.x在被分析后,形成的抽象语法树结构是 Fieldref(Class(”A1”), NameAndType(”x”, ”I”))。

那么解析A.x这样的结构的逻辑是，在加载进来的方法区中，先找到类A，然后找到名字为"x"，且类型为"I"即int型的字段，最后把指向该字段的指针存储到常量池该字段的值中。
具体的，对所有的常量池的类型，共有五种常量需要解析，分别是类，字段引用，方法引用，接口方法引用，字符串常量。

**①类**

* 类解析的任务是针对给定的**类的名字**,在类存储区中找到名字相同的类,并且把该类的指针 赋值给常量池中相应的表项。

有两个问题是类解析中必须考虑的:

* 一是如果待查找的类在类存储区不存在的话,则 需要进行加载(如果找
不到需要加载的类,需要抛出异常),所以类的解析会递归调用 到类的加载;
* 第二个问题是,如果被加载的类是数组类,那么会调用数组类的创建方法 直接在类存储区中直接创建。
---------------------------

**②字段引用**

* 字段引用的解析的任务是针对给定的字段(包括所声明的类型、字段名称、字段类型), 找到该字段,并且把指向该字段的指针赋值给常量池中相应的表项。

*  **字段引用的解析会先在类的继承关系中递归进行，然后是接口的继承关系中递归进行。即
如果在这个类本身的数据结构中没有找到该字段的话,必须到父类中继续递归查找，如果仍然没有查找到所需要的字段，则会查找该声明类的所有直接父接又以及父接又所继承的所有接口。**

概念比较抽象，我们举个简单的例子:
```java
interface I{
  static int i = 2;
}
class A{
  static int x = 99;
}
class B extends A implements I{
  static int y = x + i;
}
```
类B中存在两个字段引用:Fieldref(Class(”B”), Name-AndType(”x”, ”I”))以及 Fieldref(Class(”B”), NameAndType(i,”I”))。

对第一个字段引用,算法会在当前的类 B中进行查找,接着会在父类A中递归查找。而对于第二个字段,
也会在父类中递归查找,但 查找会失败,接着,会在A的父接又中进行查找。这两个字段的引用会分别被替换成指向 类A和接又I中相应字段的指针。

-------------------------
**③方法引用**

* 方法引用解析的任务是把对给定的方法引用(包括所声明的类型、方法名称、方法类型), 找到该方法的定义点,并且把指向该方法的指针赋值给常量池中相应的表
项。
* 查找到的方法和未来在解释引擎中对这些方法的使用是密切相关的。如果 找到的方法是静态的,那
么它将会被invokestatic指令调用;如果找到的方法 是类中的非静态方法,那么它将会被invokevirtual或者invoke-
special指令 调用;如果解析到的是位于接又中的方法,则会被invokeinterface或 invokevirtual调用。

* **值得注意的一点，在JVM解析阶段，解析的方法并不一定最终被执行。尤其对于非静态方法而言，在运行时才会解析到真正被调用执行的方法，而在解析阶段，可能它们并未被解析**

* 对方法引用的解析同样是递归的:如果在当前类中找不到 的话,会递归在
当前类的所有父类中查找,一直到Object类。另外,如果在当前类及所有父类中查找失败的话,则需在当前类
的所有父接口中进行查找。初看起来,这比较奇怪,因为在需要在当前类及父类中不能找到该方法,却能在父
接口中找到,**意味着这样一个事实:当前类实现该接口,但却未实现接又中的某些方法。**

关于方法引用的最后一点，在阅读JVM的相关资料时，我了解到sun公司在实现虚拟机的早期遇到了一个bug，后来被称为**"Miranda困境"**，想和大家分享一下。

在Java中,允许抽象类不实现接口中的方法,考虑如下的例子:

```java
interface I{
    void foo();
}
abstract class Miranda implements I{
    public Miranda(){
        foo();
    }
}
class Main extends Miranda{
    pubic static void main(String[] args){
        new Main();
    }
    public void foo(){}
}
```
在类Miranda的常量池中包括方法引用Methodref(Class(”Miranda”),name(”foo”), type(”()V”)), 在类Miranda和父类中无法解
析到该方法,因此将在类所实现的接又I中进行解析。

对米兰达方法至少有两类实现技术:一是在准备阶段,对被解析的类C,分析并收集 没有被类C所实现的
接又方法,并且在类C的虚函数表中增加虚拟的表项给这些方法 分配空间;二是不把这些方法放到符号表中,
而是直接解析为接又中的方法, 在解释引擎中按照接又方法的方式进行调用。

-----------------------
**④接口方法引用**

接口方法的解析和方法解析的算法类似,简单来说,就是要到给定的接口中 查找相应的方法,如果该接口不存
在该方法的话,则需要到该接口的父接口中递归进行查找。该算法如下:

```java
void resolveInterfaceMethodref(class, name, type)
if(class is not an interface)
error("require␣an␣interface")
foreach(method m in class)
if(m.name==name && m.type==type)
return m
foreach(parent interface c of class)
return resolveInterfaceMethodref(c, name, type)
```

算法接受三个参数:目标接口、正在被解析的接口方法引用的名字及类型。解析算法有三个关键步骤:首
先,回验证当前传入的第一个参数确实是接口类型;然后查找该接又中的每一个方法,如果找到匹配的方法则
直接返回,这里有个细节需要注意:并不是在接口对象上的方法调用都是接口方法引用, 考虑下面的例子:

```java
interface I{
    void foo();
}
class Test{
    public void f(I x){
        x.foo();
        x.toString();
    }
}
```

对接口类型的对象x,经过对其方法foo()和toString()的调用看起来语法形式类似, 但x.foo()中的方法foo在常
量池里是一个接口方法引用 InterfaceMethodref(Class(”I”,NameAndType(”foo”, ”()V”))), 而x.toString()中的方法toString
是一个方法引用Methodref(Class(”Object”), NameAndType(”toString”,”()Ljava/lang/String;”));(对应的,在指令中,前者是
invoke-interface,而后者是invoke-virtual)。可以看到,对接口方法的解析最终取决于编译器生成的代码,即最
终该方法一定会解析到某个接口上的方法,而并非在接口对象上 调用的方法都会需要接口方法解析。


* **其他解析**
* 运行时常量池中还包括其他类型的表项:整数(以及长整数)、浮点数(单双精度)、名字类型对。对于整型
和浮点型,因为本身已经是基本类型,因此无需再进行解析,对于名字类型对,因为在代码中不会出现对他们
的直接引用,所以也不需要进行解析。


------------
### 三、初始化

和类加载器的其他过程不同，JVM规范中对类初始化过程做了严格规定。

规定很多，我在这里不一一介绍，但有一条，对Java开发者也有帮助：

**所有ava虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才初始化他们，下面六种情况符合首次主动使用要求。　**

① 创建类的实例　　　　

②访问某个类或接口的非常量静态域，或者对该非常量静态域赋值

③ 调用类的静态方法

④反射（如Class.forName(“com.test.Test”)(其中Test为一个类)，而Test.class就不是首次使用)

⑤初始化一个类的子类

⑥Java虚拟机启动时被标明为启动类的类（Test）(Test为包含了程序入口main方法的类)


**对于Java开发而言有几点注意事项：**

* 类的初始化会调用类中名字为<clinit>的特殊方法,对类执行初始化的工作。方法 <clinit>不是程序员直接书写
的源代码,而是由Java编译器收集类中的**静态赋值的代码和静态代码块而成**,所以从代码层面来说,其实可以
执行任意代码。

* 类的初始化可能在正常执行流的中间的任意位置进行.从执行流程上看,这样的执行流非常类似于操作系统内核的中断机制:在正常执行的
过程中,发生了中断信号,内核暂停当前的执行流,去进行信号处理函数,执行完成后,继续从前面的暂停点继续运行。

* 在初始化过程中一般总是伴随着递归，所以**当第一次进入初始化过程后，类就被标记为正在处于初始化的类，不会再次触发初始化(即类中的static语句段不会被递归执行)**


### 四、总结

这篇博客写了俩天，酝酿了近一个月，期间查找翻阅了很多资料，想了很久才把整个思路捋清楚，希望大家多提意见，有不足之处还请见谅。

回归题目开头的那道题目，我来写一遍我理解的简单步骤，对应步骤出现的原因，可以重新看文章内容。

①装载Jtlyc：类Jtlyc被加载进JVM。
②准备，解析Jtlyc
③执行Jtlyc：出发了jtClassLoader
