# JNI
JNI是Java Native Interface的缩写，在代码里是native修饰符，它提供了大量API实现了Java和其他语言的通信。

在我接触的Java工程里，JNI主要是用来和C/C++通信去实现一些底层的设计，还被用来提升工程的性能和运行效率。

我之前听说过很多关于JNI的知识，但没有亲身实践过，借着JVMP项目的机会，实践了一把，把JNI初学者会遇到的问题分享一下。

## 带有native方法的hello.java

使用JNI的第一步，就是要写一个native方法，也叫作本地方法调用。一旦这个函数有了native前缀，JVM将不会在Java代码里寻找它的实现，而是用过本地的其他语言来实现，
我们这里介绍的是用C来实现本地方法调用，来看下面的一个例子

```java
public class hello {
    int a = 0;
    public int Add(int x,int y){
        while(y>0){
            y--;
            x++;
        }
        a = 6;
        return x;
    }
    public static void main(String[] args){
        int x = 2;
        int y = 3;
        hello test = new hello();
        System.out.println(test.a);
        System.out.println(test.Add(x,y));
        System.out.println(test.a);
    }
}
```
**hello类里有一个Add的public方法，它实现了俩参数相加，并将方法的域a做了修改。我们下面通过本地方法调用，来实现这个功能，看下面的代码**
```java
public class hello {
    static {
        System.loadLibrary("demo");
    }
    int a = 0;
    public native int Add(int x,int y);  //使用native
    public static void main(String[] args){
        int x = 2;
        int y = 3;
        hello test = new hello();
        System.out.println(test.a);
        System.out.println(test.Add(x,y));
        System.out.println(test.a);
    }
}
```

将函数Add修改为native方法，并且告诉JVM去动态链接库"demo"中去寻找Add方法的实现。

## 实现动态链接库demo.so(这里以linux平台为例，window为dll文件)

执行命令
```
javac hello.java
javah hello.java
```
得到动态链接的头文件，打开hello.h,内容如下

```C
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class hello */

#ifndef _Included_hello
#define _Included_hello
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     hello
 * Method:    Add
 * Signature: (II)I
 */
JNIEXPORT jint JNICALL Java_hello_Add
  (JNIEnv *, jobject, jint, jint);

#ifdef __cplusplus
}
#endif
#endif
```
里面的函数名JNICALL Java_hello_Add便是根据JNI规则，自动匹配生成的。这个函数名会帮助函数自己找到在java代码中的位置。

下面我们就要实现这个函数的内容:

```C
#include <stdlib.h>
#include "hello.h"
JNIEXPORT jint JNICALL Java_hello_Add(JNIEnv *env, jobject obj, jint x, jint y){
    while(y>0){
	y--;
	x++;
    }
    jfieldID fid = (*env)->GetFieldID(env,r0, "a", "I");
    (*env)->SetIntField(env, obj_r0, fid_r0_a , 6);
    return x;
}
```

里面的while循环就是实现java代码中一样的加法功能。

**值得注意的是这里寻找对象的域a的id的过程，确定一个域的位置，需要首先确定这个域所在的类/对象，接着确定这个域的域名和域的flag。比如int型为I，string类型则为Ljava/lang/String。**
然后将这个域id即代码中的jfieldID fid，传入JNI接口提供的函数SetIntField中去对这个域做值修改，实现原Java代码中的"a = 6"。

**下面通过gcc的命令，去做出自己的hello.so**

```
gcc -I/home/liuyichen/java/jdk1.8.0_131/include/ -I /home/liuyichen/java/jdk1.8.0_131/include/linux myNative.c -fPIC -shared -o libdemo.so

```
**注意：**
* 生成的so文件名，必须以lib开头，比如我们这里在java中调用了demo，则生成的库名为libdemo.so
* gcc可能会找不到jni.h所在的位置，所以必须用-I来告诉它
* -fPIC参数可以自己根据要求修改，相关内容请百度

## 试一试
有了动态链接库，那么这个java代码就可以正常运行了。可能会出现找不到库demo的问题，可以试一试下面的命令
```
java -Djava.library.path=. hello
```

